// AUTOGENERATED, DO NOT EDIT!
 /* eslint-disable */
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// ../../node_modules/mime/Mime.js
var require_Mime = __commonJS({
  "../../node_modules/mime/Mime.js"(exports, module) {
    "use strict";
    function Mime() {
      this._types = /* @__PURE__ */ Object.create(null);
      this._extensions = /* @__PURE__ */ Object.create(null);
      for (let i = 0; i < arguments.length; i++) {
        this.define(arguments[i]);
      }
      this.define = this.define.bind(this);
      this.getType = this.getType.bind(this);
      this.getExtension = this.getExtension.bind(this);
    }
    Mime.prototype.define = function(typeMap, force) {
      for (let type in typeMap) {
        let extensions = typeMap[type].map(function(t) {
          return t.toLowerCase();
        });
        type = type.toLowerCase();
        for (let i = 0; i < extensions.length; i++) {
          const ext = extensions[i];
          if (ext[0] === "*") {
            continue;
          }
          if (!force && ext in this._types) {
            throw new Error(
              'Attempt to change mapping for "' + ext + '" extension from "' + this._types[ext] + '" to "' + type + '". Pass `force=true` to allow this, otherwise remove "' + ext + '" from the list of extensions for "' + type + '".'
            );
          }
          this._types[ext] = type;
        }
        if (force || !this._extensions[type]) {
          const ext = extensions[0];
          this._extensions[type] = ext[0] !== "*" ? ext : ext.substr(1);
        }
      }
    };
    Mime.prototype.getType = function(path) {
      path = String(path);
      let last = path.replace(/^.*[/\\]/, "").toLowerCase();
      let ext = last.replace(/^.*\./, "").toLowerCase();
      let hasPath = last.length < path.length;
      let hasDot = ext.length < last.length - 1;
      return (hasDot || !hasPath) && this._types[ext] || null;
    };
    Mime.prototype.getExtension = function(type) {
      type = /^\s*([^;\s]*)/.test(type) && RegExp.$1;
      return type && this._extensions[type.toLowerCase()] || null;
    };
    module.exports = Mime;
  }
});

// ../../node_modules/mime/types/standard.js
var require_standard = __commonJS({
  "../../node_modules/mime/types/standard.js"(exports, module) {
    module.exports = { "application/andrew-inset": ["ez"], "application/applixware": ["aw"], "application/atom+xml": ["atom"], "application/atomcat+xml": ["atomcat"], "application/atomdeleted+xml": ["atomdeleted"], "application/atomsvc+xml": ["atomsvc"], "application/atsc-dwd+xml": ["dwd"], "application/atsc-held+xml": ["held"], "application/atsc-rsat+xml": ["rsat"], "application/bdoc": ["bdoc"], "application/calendar+xml": ["xcs"], "application/ccxml+xml": ["ccxml"], "application/cdfx+xml": ["cdfx"], "application/cdmi-capability": ["cdmia"], "application/cdmi-container": ["cdmic"], "application/cdmi-domain": ["cdmid"], "application/cdmi-object": ["cdmio"], "application/cdmi-queue": ["cdmiq"], "application/cu-seeme": ["cu"], "application/dash+xml": ["mpd"], "application/davmount+xml": ["davmount"], "application/docbook+xml": ["dbk"], "application/dssc+der": ["dssc"], "application/dssc+xml": ["xdssc"], "application/ecmascript": ["es", "ecma"], "application/emma+xml": ["emma"], "application/emotionml+xml": ["emotionml"], "application/epub+zip": ["epub"], "application/exi": ["exi"], "application/express": ["exp"], "application/fdt+xml": ["fdt"], "application/font-tdpfr": ["pfr"], "application/geo+json": ["geojson"], "application/gml+xml": ["gml"], "application/gpx+xml": ["gpx"], "application/gxf": ["gxf"], "application/gzip": ["gz"], "application/hjson": ["hjson"], "application/hyperstudio": ["stk"], "application/inkml+xml": ["ink", "inkml"], "application/ipfix": ["ipfix"], "application/its+xml": ["its"], "application/java-archive": ["jar", "war", "ear"], "application/java-serialized-object": ["ser"], "application/java-vm": ["class"], "application/javascript": ["js", "mjs"], "application/json": ["json", "map"], "application/json5": ["json5"], "application/jsonml+json": ["jsonml"], "application/ld+json": ["jsonld"], "application/lgr+xml": ["lgr"], "application/lost+xml": ["lostxml"], "application/mac-binhex40": ["hqx"], "application/mac-compactpro": ["cpt"], "application/mads+xml": ["mads"], "application/manifest+json": ["webmanifest"], "application/marc": ["mrc"], "application/marcxml+xml": ["mrcx"], "application/mathematica": ["ma", "nb", "mb"], "application/mathml+xml": ["mathml"], "application/mbox": ["mbox"], "application/mediaservercontrol+xml": ["mscml"], "application/metalink+xml": ["metalink"], "application/metalink4+xml": ["meta4"], "application/mets+xml": ["mets"], "application/mmt-aei+xml": ["maei"], "application/mmt-usd+xml": ["musd"], "application/mods+xml": ["mods"], "application/mp21": ["m21", "mp21"], "application/mp4": ["mp4s", "m4p"], "application/msword": ["doc", "dot"], "application/mxf": ["mxf"], "application/n-quads": ["nq"], "application/n-triples": ["nt"], "application/node": ["cjs"], "application/octet-stream": ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"], "application/oda": ["oda"], "application/oebps-package+xml": ["opf"], "application/ogg": ["ogx"], "application/omdoc+xml": ["omdoc"], "application/onenote": ["onetoc", "onetoc2", "onetmp", "onepkg"], "application/oxps": ["oxps"], "application/p2p-overlay+xml": ["relo"], "application/patch-ops-error+xml": ["xer"], "application/pdf": ["pdf"], "application/pgp-encrypted": ["pgp"], "application/pgp-signature": ["asc", "sig"], "application/pics-rules": ["prf"], "application/pkcs10": ["p10"], "application/pkcs7-mime": ["p7m", "p7c"], "application/pkcs7-signature": ["p7s"], "application/pkcs8": ["p8"], "application/pkix-attr-cert": ["ac"], "application/pkix-cert": ["cer"], "application/pkix-crl": ["crl"], "application/pkix-pkipath": ["pkipath"], "application/pkixcmp": ["pki"], "application/pls+xml": ["pls"], "application/postscript": ["ai", "eps", "ps"], "application/provenance+xml": ["provx"], "application/pskc+xml": ["pskcxml"], "application/raml+yaml": ["raml"], "application/rdf+xml": ["rdf", "owl"], "application/reginfo+xml": ["rif"], "application/relax-ng-compact-syntax": ["rnc"], "application/resource-lists+xml": ["rl"], "application/resource-lists-diff+xml": ["rld"], "application/rls-services+xml": ["rs"], "application/route-apd+xml": ["rapd"], "application/route-s-tsid+xml": ["sls"], "application/route-usd+xml": ["rusd"], "application/rpki-ghostbusters": ["gbr"], "application/rpki-manifest": ["mft"], "application/rpki-roa": ["roa"], "application/rsd+xml": ["rsd"], "application/rss+xml": ["rss"], "application/rtf": ["rtf"], "application/sbml+xml": ["sbml"], "application/scvp-cv-request": ["scq"], "application/scvp-cv-response": ["scs"], "application/scvp-vp-request": ["spq"], "application/scvp-vp-response": ["spp"], "application/sdp": ["sdp"], "application/senml+xml": ["senmlx"], "application/sensml+xml": ["sensmlx"], "application/set-payment-initiation": ["setpay"], "application/set-registration-initiation": ["setreg"], "application/shf+xml": ["shf"], "application/sieve": ["siv", "sieve"], "application/smil+xml": ["smi", "smil"], "application/sparql-query": ["rq"], "application/sparql-results+xml": ["srx"], "application/srgs": ["gram"], "application/srgs+xml": ["grxml"], "application/sru+xml": ["sru"], "application/ssdl+xml": ["ssdl"], "application/ssml+xml": ["ssml"], "application/swid+xml": ["swidtag"], "application/tei+xml": ["tei", "teicorpus"], "application/thraud+xml": ["tfi"], "application/timestamped-data": ["tsd"], "application/toml": ["toml"], "application/trig": ["trig"], "application/ttml+xml": ["ttml"], "application/ubjson": ["ubj"], "application/urc-ressheet+xml": ["rsheet"], "application/urc-targetdesc+xml": ["td"], "application/voicexml+xml": ["vxml"], "application/wasm": ["wasm"], "application/widget": ["wgt"], "application/winhlp": ["hlp"], "application/wsdl+xml": ["wsdl"], "application/wspolicy+xml": ["wspolicy"], "application/xaml+xml": ["xaml"], "application/xcap-att+xml": ["xav"], "application/xcap-caps+xml": ["xca"], "application/xcap-diff+xml": ["xdf"], "application/xcap-el+xml": ["xel"], "application/xcap-ns+xml": ["xns"], "application/xenc+xml": ["xenc"], "application/xhtml+xml": ["xhtml", "xht"], "application/xliff+xml": ["xlf"], "application/xml": ["xml", "xsl", "xsd", "rng"], "application/xml-dtd": ["dtd"], "application/xop+xml": ["xop"], "application/xproc+xml": ["xpl"], "application/xslt+xml": ["*xsl", "xslt"], "application/xspf+xml": ["xspf"], "application/xv+xml": ["mxml", "xhvml", "xvml", "xvm"], "application/yang": ["yang"], "application/yin+xml": ["yin"], "application/zip": ["zip"], "audio/3gpp": ["*3gpp"], "audio/adpcm": ["adp"], "audio/amr": ["amr"], "audio/basic": ["au", "snd"], "audio/midi": ["mid", "midi", "kar", "rmi"], "audio/mobile-xmf": ["mxmf"], "audio/mp3": ["*mp3"], "audio/mp4": ["m4a", "mp4a"], "audio/mpeg": ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"], "audio/ogg": ["oga", "ogg", "spx", "opus"], "audio/s3m": ["s3m"], "audio/silk": ["sil"], "audio/wav": ["wav"], "audio/wave": ["*wav"], "audio/webm": ["weba"], "audio/xm": ["xm"], "font/collection": ["ttc"], "font/otf": ["otf"], "font/ttf": ["ttf"], "font/woff": ["woff"], "font/woff2": ["woff2"], "image/aces": ["exr"], "image/apng": ["apng"], "image/avif": ["avif"], "image/bmp": ["bmp"], "image/cgm": ["cgm"], "image/dicom-rle": ["drle"], "image/emf": ["emf"], "image/fits": ["fits"], "image/g3fax": ["g3"], "image/gif": ["gif"], "image/heic": ["heic"], "image/heic-sequence": ["heics"], "image/heif": ["heif"], "image/heif-sequence": ["heifs"], "image/hej2k": ["hej2"], "image/hsj2": ["hsj2"], "image/ief": ["ief"], "image/jls": ["jls"], "image/jp2": ["jp2", "jpg2"], "image/jpeg": ["jpeg", "jpg", "jpe"], "image/jph": ["jph"], "image/jphc": ["jhc"], "image/jpm": ["jpm"], "image/jpx": ["jpx", "jpf"], "image/jxr": ["jxr"], "image/jxra": ["jxra"], "image/jxrs": ["jxrs"], "image/jxs": ["jxs"], "image/jxsc": ["jxsc"], "image/jxsi": ["jxsi"], "image/jxss": ["jxss"], "image/ktx": ["ktx"], "image/ktx2": ["ktx2"], "image/png": ["png"], "image/sgi": ["sgi"], "image/svg+xml": ["svg", "svgz"], "image/t38": ["t38"], "image/tiff": ["tif", "tiff"], "image/tiff-fx": ["tfx"], "image/webp": ["webp"], "image/wmf": ["wmf"], "message/disposition-notification": ["disposition-notification"], "message/global": ["u8msg"], "message/global-delivery-status": ["u8dsn"], "message/global-disposition-notification": ["u8mdn"], "message/global-headers": ["u8hdr"], "message/rfc822": ["eml", "mime"], "model/3mf": ["3mf"], "model/gltf+json": ["gltf"], "model/gltf-binary": ["glb"], "model/iges": ["igs", "iges"], "model/mesh": ["msh", "mesh", "silo"], "model/mtl": ["mtl"], "model/obj": ["obj"], "model/step+xml": ["stpx"], "model/step+zip": ["stpz"], "model/step-xml+zip": ["stpxz"], "model/stl": ["stl"], "model/vrml": ["wrl", "vrml"], "model/x3d+binary": ["*x3db", "x3dbz"], "model/x3d+fastinfoset": ["x3db"], "model/x3d+vrml": ["*x3dv", "x3dvz"], "model/x3d+xml": ["x3d", "x3dz"], "model/x3d-vrml": ["x3dv"], "text/cache-manifest": ["appcache", "manifest"], "text/calendar": ["ics", "ifb"], "text/coffeescript": ["coffee", "litcoffee"], "text/css": ["css"], "text/csv": ["csv"], "text/html": ["html", "htm", "shtml"], "text/jade": ["jade"], "text/jsx": ["jsx"], "text/less": ["less"], "text/markdown": ["markdown", "md"], "text/mathml": ["mml"], "text/mdx": ["mdx"], "text/n3": ["n3"], "text/plain": ["txt", "text", "conf", "def", "list", "log", "in", "ini"], "text/richtext": ["rtx"], "text/rtf": ["*rtf"], "text/sgml": ["sgml", "sgm"], "text/shex": ["shex"], "text/slim": ["slim", "slm"], "text/spdx": ["spdx"], "text/stylus": ["stylus", "styl"], "text/tab-separated-values": ["tsv"], "text/troff": ["t", "tr", "roff", "man", "me", "ms"], "text/turtle": ["ttl"], "text/uri-list": ["uri", "uris", "urls"], "text/vcard": ["vcard"], "text/vtt": ["vtt"], "text/xml": ["*xml"], "text/yaml": ["yaml", "yml"], "video/3gpp": ["3gp", "3gpp"], "video/3gpp2": ["3g2"], "video/h261": ["h261"], "video/h263": ["h263"], "video/h264": ["h264"], "video/iso.segment": ["m4s"], "video/jpeg": ["jpgv"], "video/jpm": ["*jpm", "jpgm"], "video/mj2": ["mj2", "mjp2"], "video/mp2t": ["ts"], "video/mp4": ["mp4", "mp4v", "mpg4"], "video/mpeg": ["mpeg", "mpg", "mpe", "m1v", "m2v"], "video/ogg": ["ogv"], "video/quicktime": ["qt", "mov"], "video/webm": ["webm"] };
  }
});

// ../../node_modules/mime/lite.js
var require_lite = __commonJS({
  "../../node_modules/mime/lite.js"(exports, module) {
    "use strict";
    var Mime = require_Mime();
    module.exports = new Mime(require_standard());
  }
});

// facade/fetch-static-asset.ts
var import_lite = __toESM(require_lite());
import StaticAssetManifest from "__STATIC_ASSETS_MANIFEST__";
function getRoomAndPartyFromPathname(pathname) {
  if (pathname.startsWith("/party/")) {
    const [_, __, roomId] = pathname.split("/");
    return {
      room: roomId,
      party: "main"
    };
  } else if (pathname.startsWith("/parties/")) {
    const [_, __, partyName, roomId] = pathname.split("/");
    return {
      room: roomId,
      party: partyName
    };
  }
  return null;
}
async function fetchStaticAsset(request, _env, _ctx) {
  const SUPPORTED_METHODS = ["GET", "HEAD"];
  if (!SUPPORTED_METHODS.includes(request.method)) {
    return null;
  }
  const url = new URL(request.url);
  let response = null;
  let filePath = decodeURIComponent(url.pathname);
  if (filePath.endsWith("/")) {
    filePath += "index.html";
  }
  if (filePath !== "/" && filePath.startsWith("/")) {
    filePath = filePath.substring(1);
  }
  if (filePath in StaticAssetManifest.assets) {
    response = await fetch(
      `${StaticAssetManifest.devServer}/${StaticAssetManifest.assets[filePath]}`
    );
  }
  if (StaticAssetManifest.singlePageApp === true && response === null) {
    const { room: roomId } = getRoomAndPartyFromPathname(`/${filePath}`) || {};
    if (!roomId) {
      response = await fetch(
        `${StaticAssetManifest.devServer}/${StaticAssetManifest.assets["index.html"]}`
      );
    } else if (filePath.endsWith(".html")) {
      response = await fetch(
        `${StaticAssetManifest.devServer}/${StaticAssetManifest.assets["index.html"]}`
      );
    } else if (!import_lite.default.getType(filePath)) {
      response = await fetch(
        `${StaticAssetManifest.devServer}/${StaticAssetManifest.assets["index.html"]}`
      );
    }
  }
  return response;
}

// facade/connection.ts
if (!("OPEN" in WebSocket)) {
  const WebSocketStatus = {
    CONNECTING: WebSocket.READY_STATE_CONNECTING,
    OPEN: WebSocket.READY_STATE_OPEN,
    CLOSING: WebSocket.READY_STATE_CLOSING,
    CLOSED: WebSocket.READY_STATE_CLOSED
  };
  Object.assign(WebSocket, WebSocketStatus);
  Object.assign(WebSocket.prototype, WebSocketStatus);
}
var AttachmentCache = class {
  _cache = /* @__PURE__ */ new WeakMap();
  get(ws) {
    let attachment = this._cache.get(ws);
    if (!attachment) {
      attachment = WebSocket.prototype.deserializeAttachment.call(ws);
      if (attachment !== void 0) {
        this._cache.set(ws, attachment);
      } else {
        throw new Error(
          "Missing websocket attachment. This is most likely an issue in PartyKit, please open an issue at https://github.com/partykit/partykit/issues"
        );
      }
    }
    return attachment;
  }
  set(ws, attachment) {
    this._cache.set(ws, attachment);
    WebSocket.prototype.serializeAttachment.call(ws, attachment);
  }
};
var attachments = new AttachmentCache();
var connections = /* @__PURE__ */ new WeakSet();
var isWrapped = (ws) => {
  return connections.has(ws);
};
var createLazyConnection = (ws) => {
  if (isWrapped(ws)) {
    return ws;
  }
  let initialState = void 0;
  if ("state" in ws) {
    initialState = ws.state;
    delete ws.state;
  }
  const connection = Object.defineProperties(ws, {
    id: {
      get() {
        return attachments.get(ws).__pk.id;
      }
    },
    uri: {
      get() {
        return attachments.get(ws).__pk.uri;
      }
    },
    socket: {
      get() {
        return ws;
      }
    },
    state: {
      get() {
        return this.deserializeAttachment();
      }
    },
    setState: {
      value: function setState(setState) {
        let state;
        if (setState instanceof Function) {
          state = setState(this.state);
        } else {
          state = setState;
        }
        this.serializeAttachment(state);
        return state;
      }
    },
    deserializeAttachment: {
      value: function deserializeAttachment() {
        const attachment = attachments.get(ws);
        return attachment.__user ?? null;
      }
    },
    serializeAttachment: {
      value: function serializeAttachment(attachment) {
        const setting = {
          ...attachments.get(ws),
          __user: attachment ?? null
        };
        attachments.set(ws, setting);
      }
    }
  });
  if (initialState) {
    connection.setState(initialState);
  }
  connections.add(connection);
  return connection;
};
var HibernatingConnectionIterator = class {
  constructor(state, tag) {
    this.state = state;
    this.tag = tag;
  }
  index = 0;
  sockets;
  [Symbol.iterator]() {
    return this;
  }
  next() {
    const sockets = this.sockets ?? (this.sockets = this.state.getWebSockets(this.tag));
    let socket;
    while (socket = sockets[this.index++]) {
      if (socket.readyState === WebSocket.READY_STATE_OPEN) {
        const value = createLazyConnection(socket);
        return { done: false, value };
      }
    }
    return { done: true, value: void 0 };
  }
};
var InMemoryConnectionManager = class {
  connections = /* @__PURE__ */ new Map();
  tags = /* @__PURE__ */ new WeakMap();
  getCount() {
    return this.connections.size;
  }
  getConnection(id) {
    return this.connections.get(id);
  }
  *getConnections(tag) {
    if (!tag) {
      yield* this.connections.values();
      return;
    }
    for (const connection of this.connections.values()) {
      const connectionTags = this.tags.get(connection) ?? [];
      if (connectionTags.includes(tag)) {
        yield connection;
      }
    }
  }
  legacy_getConnectionMap() {
    return this.connections;
  }
  accept(connection, tags) {
    connection.accept();
    this.connections.set(connection.id, connection);
    this.tags.set(connection, [
      // make sure we have id tag
      connection.id,
      ...tags.filter((t) => t !== connection.id)
    ]);
    const removeConnection = () => {
      this.connections.delete(connection.id);
      connection.removeEventListener("close", removeConnection);
      connection.removeEventListener("error", removeConnection);
    };
    connection.addEventListener("close", removeConnection);
    connection.addEventListener("error", removeConnection);
    return connection;
  }
};
var HibernatingConnectionManager = class {
  constructor(controller) {
    this.controller = controller;
  }
  getCount() {
    return Number(this.controller.getWebSockets().length);
  }
  getConnection(id) {
    const sockets = this.controller.getWebSockets(id);
    if (sockets.length === 0)
      return void 0;
    if (sockets.length === 1)
      return createLazyConnection(sockets[0]);
    throw new Error(
      `More than one connection found for id ${id}. Did you mean to use getConnections(tag) instead?`
    );
  }
  getConnections(tag) {
    return new HibernatingConnectionIterator(this.controller, tag);
  }
  legacy_getConnectionMap() {
    const connections2 = /* @__PURE__ */ new Map();
    for (const connection of this.getConnections()) {
      connections2.set(connection.id, connection);
    }
    return connections2;
  }
  accept(connection, userTags) {
    const tags = [
      connection.id,
      ...userTags.filter((t) => t !== connection.id)
    ];
    if (tags.length > 10) {
      throw new Error(
        "A connection can only have 10 tags, including the default id tag."
      );
    }
    for (const tag of tags) {
      if (typeof tag !== "string") {
        throw new Error(`A connection tag must be a string. Received: ${tag}`);
      }
      if (tag === "") {
        throw new Error(`A connection tag must not be an empty string.`);
      }
      if (tag.length > 256) {
        throw new Error(`A connection tag must not exceed 256 characters`);
      }
    }
    this.controller.acceptWebSocket(connection, tags);
    connection.serializeAttachment({
      __pk: {
        id: connection.id,
        uri: connection.uri
      },
      __user: null
    });
    return createLazyConnection(connection);
  }
};

// facade/worker.ts
var ModuleWorker = class {
  constructor(worker, party) {
    this.worker = worker;
    this.party = party;
    this.supportsHibernation = "onMessage" in worker || !(`onConnect` in worker);
  }
  options = {};
  supportsHibernation;
  onStart() {
  }
  onConnect(ws, ctx) {
    if (this.worker.onConnect) {
      return this.worker.onConnect(ws, this.party, ctx);
    }
  }
  onMessage(message, ws) {
    if (this.worker.onMessage) {
      return this.worker.onMessage(message, ws, this.party);
    }
  }
  onClose(ws) {
    if (this.worker.onClose) {
      return this.worker.onClose(ws, this.party);
    }
  }
  onError(ws, err) {
    if (this.worker.onError) {
      return this.worker.onError(ws, err, this.party);
    }
  }
  onRequest(req) {
    if (this.worker.onRequest) {
      return this.worker.onRequest(req, this.party);
    }
    return new Response("Invalid onRequest handler", {
      status: 500
    });
  }
  onAlarm() {
    if (this.worker.onAlarm) {
      return this.worker.onAlarm(this.party);
    }
  }
  getConnectionTags() {
    return [];
  }
};
var ClassWorker = class {
  constructor(Worker2, party) {
    this.Worker = Worker2;
    this.party = party;
    this.worker = new Worker2(party);
    this.options = this.worker.options ?? {};
    this.supportsHibernation = this.options.hibernate === true;
  }
  worker;
  options;
  supportsHibernation;
  onStart() {
    if (this.worker.onStart) {
      return this.worker.onStart();
    }
  }
  onConnect(ws, ctx) {
    if (this.worker.onConnect) {
      return this.worker.onConnect(ws, ctx);
    }
  }
  onMessage(message, ws) {
    if (this.worker.onMessage) {
      return this.worker.onMessage(message, ws);
    }
  }
  onClose(ws) {
    if (this.worker.onClose) {
      return this.worker.onClose(ws);
    }
  }
  onError(ws, err) {
    if (this.worker.onError) {
      return this.worker.onError(ws, err);
    }
  }
  onRequest(req) {
    if (this.worker.onRequest) {
      return this.worker.onRequest(req);
    }
    return new Response("Invalid onRequest handler", {
      status: 500
    });
  }
  onAlarm() {
    if (this.worker.onAlarm) {
      return this.worker.onAlarm();
    }
  }
  getConnectionTags(connection, context) {
    if (this.worker.getConnectionTags) {
      return this.worker.getConnectionTags(connection, context);
    }
    return [];
  }
};

// facade/source.ts
import Worker from "__WORKER__";
function assert(condition, msg) {
  if (!condition) {
    throw new Error(msg);
  }
}
function getRoomAndPartyFromPathname2(pathname) {
  if (pathname.startsWith("/party/")) {
    const [_, __, roomId] = pathname.split("/");
    return {
      room: roomId,
      party: "main"
    };
  } else if (pathname.startsWith("/parties/")) {
    const [_, __, partyName, roomId] = pathname.split("/");
    return {
      room: roomId,
      party: partyName
    };
  }
  return null;
}
var didWarnAboutMissingConnectionId = false;
function isClassWorker(worker) {
  return typeof worker === "function" && "prototype" in worker && worker.prototype instanceof Object;
}
var PartyDurable = class {
};
var parties;
function createMultiParties(namespaces, options) {
  if (!parties) {
    parties = {};
    for (const [key, value] of Object.entries(namespaces)) {
      if (typeof value.idFromName === "function") {
        parties[key] ||= {
          get: (name) => {
            const docId = value.idFromName(name).toString();
            const id = value.idFromString(docId);
            const stub = value.get(id);
            return {
              fetch(pathOrInit, maybeInit) {
                let path;
                let init;
                if (pathOrInit) {
                  if (typeof pathOrInit === "string") {
                    path = pathOrInit;
                    init = maybeInit;
                    if (path[0] !== "/") {
                      throw new Error("Path must start with /");
                    }
                    return stub.fetch(
                      `http://${options.host}/parties/${key}/${name}${path}`,
                      init
                    );
                  } else {
                    init = pathOrInit;
                    return stub.fetch(
                      `http://${options.host}/parties/${key}/${name}`,
                      init
                    );
                  }
                } else {
                  return stub.fetch(
                    `http://${options.host}/parties/${key}/${name}`
                  );
                }
              },
              connect: () => {
                return new WebSocket(
                  `ws://${options.host}/parties/${key}/${name}`
                );
              },
              async socket(pathOrInit, maybeInit) {
                let res;
                let path;
                let init;
                if (pathOrInit) {
                  if (typeof pathOrInit === "string") {
                    path = pathOrInit;
                    init = maybeInit;
                    if (path[0] !== "/") {
                      throw new Error("Path must start with /");
                    }
                    res = await stub.fetch(
                      `http://${options.host}/parties/${key}/${name}${path}`,
                      {
                        ...init,
                        headers: {
                          upgrade: "websocket",
                          ...init?.headers
                        }
                      }
                    );
                  } else {
                    init = pathOrInit;
                    res = await stub.fetch(
                      `http://${options.host}/parties/${key}/${name}`,
                      {
                        ...init,
                        headers: {
                          upgrade: "websocket",
                          ...init?.headers
                        }
                      }
                    );
                  }
                } else {
                  res = await stub.fetch(
                    `http://${options.host}/parties/${key}/${name}`,
                    {
                      headers: {
                        upgrade: "websocket"
                      }
                    }
                  );
                }
                const ws = res.webSocket;
                if (!ws) {
                  throw new Error("Expected a websocket response");
                }
                ws.accept();
                return ws;
              }
            };
          }
        };
      }
    }
  }
  return parties;
}
function createDurable(Worker2, options) {
  const isClassAPI = isClassWorker(Worker2);
  const WorkerInstanceMethods = isClassWorker(Worker2) ? Worker2.prototype : Worker2;
  for (const handler of [
    "onConnect",
    "onRequest",
    "onMessage",
    "onClose",
    "onError",
    "onAlarm"
  ]) {
    if (handler in Worker2 && typeof Worker2[handler] !== "function") {
      throw new Error(`.${handler} should be a function`);
    }
  }
  for (const handler of [
    "unstable_onFetch",
    "onFetch",
    "onBeforeConnect",
    "onBeforeRequest"
  ]) {
    if (handler in WorkerInstanceMethods) {
      if (isClassAPI) {
        console.warn(
          `.${handler} is present on the class instance, but it should be defined as a static method`
        );
      }
      if (typeof WorkerInstanceMethods[handler] !== "function") {
        throw new Error(`.${handler} should be a function`);
      }
    }
  }
  return class extends PartyDurable {
    controller;
    room;
    namespaces;
    inAlarm = false;
    // used to prevent access to certain properties in onAlarm
    // assigned when first connection is received
    id;
    worker;
    parties;
    connectionManager;
    constructor(controller, env) {
      super();
      const { PARTYKIT_VARS, PARTYKIT_DURABLE, ...namespaces } = env;
      this.controller = controller;
      this.namespaces = namespaces;
      Object.assign(this.namespaces, {
        main: PARTYKIT_DURABLE
      });
      const self = this;
      this.room = {
        get id() {
          if (self.inAlarm) {
            throw new Error(
              "You can not access `Party.id` in the `onAlarm` handler.\nThis is a known limitation, and may be fixed in a future version of PartyKit.\nIf you access to the id, you can save it into the Party storage when setting the alarm.\n"
            );
          }
          if (self.id) {
            return self.id;
          }
          throw new Error(
            "Party.id is not yet initialized. This is probably a bug in PartyKit."
          );
        },
        internalID: this.controller.id.toString(),
        name: options.name,
        env: PARTYKIT_VARS,
        storage: this.controller.storage,
        broadcast: this.broadcast,
        context: {
          get parties() {
            if (self.inAlarm) {
              throw new Error(
                "You can not access `Party.context.parties` in the `onAlarm` handler.\nThis is a known limitation, and may be fixed in a future version of PartyKit."
              );
            }
            if (self.parties) {
              return self.parties;
            }
            throw new Error(
              "Parties are not yet initialized. This is probably a bug in PartyKit."
            );
          }
        },
        getConnection(id) {
          if (self.connectionManager) {
            return self.connectionManager.getConnection(id);
          }
          console.warn(
            ".getConnection was invoked before first connection. This will always return undefined."
          );
          return void 0;
        },
        getConnections(tag) {
          if (self.connectionManager) {
            return self.connectionManager.getConnections(tag);
          }
          console.warn(
            "Party.getConnections was invoked before first connection. This will always return an empty list."
          );
          return [].values();
        },
        /// @deprecated, supported for backwards compatibility only
        get connections() {
          console.warn(
            "Party.connections is deprecated and will be removed in a future version of PartyKit. Use Party.getConnections() instead."
          );
          if (self.connectionManager) {
            return self.connectionManager.legacy_getConnectionMap();
          }
          console.warn(
            "Party.connections was invoked before first connection. This will always return an empty Map."
          );
          return /* @__PURE__ */ new Map();
        },
        get parties() {
          console.warn(
            "Party.parties is deprecated and will be removed in a future version of PartyKit. Use Party.context.parties instead."
          );
          return this.context.parties;
        }
      };
    }
    broadcast = (msg, without = []) => {
      if (!this.connectionManager) {
        return;
      }
      for (const connection of this.connectionManager.getConnections()) {
        if (!without.includes(connection.id)) {
          connection.send(msg);
        }
      }
    };
    async fetch(req) {
      const request = req;
      const url = new URL(request.url);
      try {
        if (!this.worker) {
          await this.initialize(request.url);
        }
        assert(this.worker, "Worker not initialized.");
        assert(this.connectionManager, "ConnectionManager not initialized.");
        if (request.headers.get("upgrade")?.toLowerCase() !== "websocket") {
          return await this.worker.onRequest(request);
        }
      } catch (e) {
        console.error("onRequest error", e);
        const errMessage = e instanceof Error ? e.message : `${e}`;
        const errCode = "code" in e ? e.code : 500;
        return new Response(
          errMessage || "Uncaught exception when making a request",
          {
            status: errCode
          }
        );
      }
      try {
        if (!("onConnect" in this.worker && typeof this.worker.onConnect === "function" || "onMessage" in this.worker && typeof this.worker.onMessage === "function")) {
          throw new Error("No onConnect or onMessage handler");
        }
        const { 0: clientWebSocket, 1: serverWebSocket } = new WebSocketPair();
        let connectionId = url.searchParams.get("_pk");
        if (!connectionId) {
          if (!didWarnAboutMissingConnectionId) {
            didWarnAboutMissingConnectionId = true;
            console.warn(
              "No connection id found in request url, generating one"
            );
          }
          connectionId = crypto.randomUUID();
        }
        let connection = Object.assign(serverWebSocket, {
          id: connectionId,
          socket: serverWebSocket,
          uri: request.url,
          state: null,
          setState(setState) {
            let state;
            if (setState instanceof Function) {
              state = setState(this.state);
            } else {
              state = setState;
            }
            this.state = state;
            return this.state;
          }
        });
        const ctx = { request };
        const tags = await this.worker.getConnectionTags(connection, ctx);
        connection = this.connectionManager.accept(connection, tags);
        if (!this.worker.supportsHibernation) {
          await this.attachSocketEventHandlers(connection);
        }
        await this.worker.onConnect(connection, ctx);
        return new Response(null, { status: 101, webSocket: clientWebSocket });
      } catch (e) {
        console.error("Error when connecting");
        console.error(e);
        const errMessage = e instanceof Error ? e.message : `${e}`;
        const pair = new WebSocketPair();
        pair[1].accept();
        pair[1].close(1011, errMessage || "Uncaught exception when connecting");
        return new Response(null, { status: 101, webSocket: pair[0] });
      }
    }
    /**
     * Parties can only be created once we have a request URL.
     * This method should be called when the durable object receives its
     * first connection, or is woken up from hibernation.
     */
    async initialize(requestUri) {
      this.#initializeParty(requestUri);
      return this.#initializeWorker();
    }
    #initializeParty(requestUri) {
      const url = new URL(requestUri);
      const roomId = getRoomAndPartyFromPathname2(url.pathname)?.room;
      assert(roomId, "No room id found in request url");
      this.id = roomId;
      this.parties = createMultiParties(this.namespaces, {
        host: url.host
      });
    }
    async #initializeWorker() {
      this.worker = isClassAPI ? new ClassWorker(Worker2, this.room) : new ModuleWorker(Worker2, this.room);
      this.connectionManager = this.worker.supportsHibernation ? new HibernatingConnectionManager(this.controller) : new InMemoryConnectionManager();
      return this.worker.onStart();
    }
    async attachSocketEventHandlers(connection) {
      assert(this.worker, "[onConnect] Worker not initialized.");
      const handleMessageFromClient = (event) => {
        this.invokeOnMessage(connection, event.data).catch((e) => {
          console.error(e);
        });
      };
      const handleCloseFromClient = () => {
        connection.removeEventListener("message", handleMessageFromClient);
        connection.removeEventListener("close", handleCloseFromClient);
        this.invokeOnClose(connection).catch((e) => {
          console.error(e);
        });
      };
      const handleErrorFromClient = (e) => {
        connection.removeEventListener("message", handleMessageFromClient);
        connection.removeEventListener("error", handleErrorFromClient);
        this.invokeOnError(connection, e.error).catch((e2) => {
          console.error(e2);
        });
      };
      connection.addEventListener("close", handleCloseFromClient);
      connection.addEventListener("error", handleErrorFromClient);
      connection.addEventListener("message", handleMessageFromClient);
    }
    /** Runtime calls webSocketMessage when hibernated connection receives a message  */
    async webSocketMessage(ws, msg) {
      const connection = createLazyConnection(ws);
      if (!this.worker) {
        assert(connection.uri, "No uri found in connection");
        await this.initialize(connection.uri);
      }
      return this.invokeOnMessage(connection, msg);
    }
    /** Runtime calls webSocketClose when hibernated connection closes  */
    async webSocketClose(ws) {
      return this.invokeOnClose(createLazyConnection(ws));
    }
    /** Runtime calls webSocketError when hibernated connection errors  */
    async webSocketError(ws, err) {
      return this.invokeOnError(createLazyConnection(ws), err);
    }
    async invokeOnClose(connection) {
      assert(this.worker, "[onClose] Worker not initialized.");
      return this.worker.onClose(connection);
    }
    async invokeOnError(connection, err) {
      assert(this.worker, "[onError] Worker not initialized.");
      return this.worker.onError(connection, err);
    }
    async invokeOnMessage(connection, msg) {
      assert(this.worker, "[onMessage] Worker not initialized.");
      return this.worker.onMessage(msg, connection);
    }
    async alarm() {
      if (!this.worker) {
        await this.#initializeWorker();
        assert(this.worker, "[onAlarm] Worker not initialized.");
      }
      try {
        this.inAlarm = true;
        return await this.worker.onAlarm();
      } finally {
        this.inAlarm = false;
      }
    }
  };
}
var Workers = {
  main: Worker
};
var PartyKitDurable = createDurable(Worker, { name: "main" });
__PARTIES__;
var source_default = {
  async fetch(request, env, ctx) {
    try {
      const url = new URL(request.url);
      const { PARTYKIT_VARS, PARTYKIT_DURABLE, ...namespaces } = env;
      Object.assign(namespaces, {
        main: PARTYKIT_DURABLE
      });
      const { room: roomId, party: targetParty } = getRoomAndPartyFromPathname2(url.pathname) || {};
      const parties2 = createMultiParties(
        namespaces,
        {
          host: url.host
        }
      );
      if (roomId) {
        assert(targetParty, "No party found in request url");
        const targetWorker = Workers[targetParty];
        const targetDurable = namespaces[targetParty];
        if (!targetWorker) {
          return new Response(`Party ${targetParty} not found`, {
            status: 404
          });
        }
        const WorkerInstanceMethods = isClassWorker(
          targetWorker
        ) ? targetWorker.prototype : targetWorker;
        if (request.headers.get("upgrade")?.toLowerCase() === "websocket") {
          let connectionId = url.searchParams.get("_pk");
          if (!connectionId) {
            if (!didWarnAboutMissingConnectionId) {
              didWarnAboutMissingConnectionId = true;
              console.warn(
                "No connection id found in request url, generating one"
              );
            }
            connectionId = crypto.randomUUID();
          }
          let onBeforeConnectResponse = void 0;
          if ("onBeforeConnect" in targetWorker) {
            if (typeof targetWorker.onBeforeConnect === "function") {
              try {
                const mutableRequest = new Request(request.url, request);
                onBeforeConnectResponse = await targetWorker.onBeforeConnect(
                  mutableRequest,
                  {
                    id: roomId,
                    env: PARTYKIT_VARS,
                    parties: parties2
                  },
                  ctx
                );
              } catch (e) {
                console.error("onBeforeConnect error", e);
                return new Response(
                  e instanceof Error ? e.message : `${e}` || "Unauthorised",
                  {
                    status: 401
                  }
                );
              }
            } else {
              throw new Error(".onBeforeConnect must be a function");
            }
          }
          const docId = targetDurable.idFromName(roomId).toString();
          const id = targetDurable.idFromString(docId);
          if (onBeforeConnectResponse) {
            if (onBeforeConnectResponse instanceof Response) {
              return onBeforeConnectResponse;
            } else if (onBeforeConnectResponse instanceof Request) {
              return await targetDurable.get(id).fetch(onBeforeConnectResponse);
            }
          }
          return await targetDurable.get(id).fetch(request);
        } else {
          let onBeforeRequestResponse = request;
          if ("onBeforeRequest" in targetWorker) {
            if (typeof targetWorker.onBeforeRequest === "function") {
              try {
                const mutableRequest = new Request(request.url, request);
                onBeforeRequestResponse = await targetWorker.onBeforeRequest(
                  mutableRequest,
                  {
                    id: roomId,
                    env: PARTYKIT_VARS,
                    parties: parties2
                  },
                  ctx
                );
              } catch (e) {
                console.error("onBeforeRequest error", e);
                return new Response(
                  e instanceof Error ? e.message : `${e}` || "Unauthorised",
                  {
                    status: 401
                  }
                );
              }
            } else {
              throw new Error(".onBeforeRequest must be a function");
            }
          }
          if (onBeforeRequestResponse instanceof Response) {
            return onBeforeRequestResponse;
          }
          if (!("onRequest" in WorkerInstanceMethods)) {
            throw new Error("No onRequest handler");
          }
          const docId = targetDurable.idFromName(roomId).toString();
          const id = targetDurable.idFromString(docId);
          return await targetDurable.get(id).fetch(onBeforeRequestResponse);
        }
      } else {
        const staticAssetsResponse = await fetchStaticAsset(request, env, ctx);
        const onFetch = Worker.onFetch ?? // eslint-disable-next-line deprecation/deprecation
        Worker.unstable_onFetch;
        if (staticAssetsResponse) {
          return staticAssetsResponse;
        } else if (typeof onFetch === "function") {
          return await onFetch(
            request,
            {
              env: PARTYKIT_VARS,
              parties: parties2
            },
            ctx
          );
        }
        return new Response("Not found", {
          status: 404
        });
      }
    } catch (e) {
      console.error("fetch error", e);
      return new Response(e instanceof Error ? e.message : `${e}`, {
        status: 500
      });
    }
  }
};
export {
  PartyKitDurable,
  source_default as default
};
